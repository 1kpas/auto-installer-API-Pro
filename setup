#!/bin/bash

# Default Branding Definitions
BRAND_NAME="A.I PRO"
SUPPORT_EMAIL="contato@aipro.com"
DEFAULT_TIMEZONE="America/Sao_Paulo"

# Color Variables
amarelo='\e[33m'
verde='\e[32m'
branco='\e[97m'
vermelho='\e[31m'
reset='\e[0m'

# Function to display the application name for Traefik and Portainer
function nome_traefik_e_portainer() {
    echo -e "${verde}=== ${BRAND_NAME} - Traefik and Portainer Installer ===${reset}"
}

# Function to display the application name for Chatwoot
function nome_chatwoot() {
    echo -e "${verde}=== ${BRAND_NAME} - Chatwoot Installer ===${reset}"
}

# Function to display the application name for N8N
function nome_n8n() {
    echo -e "${verde}=== ${BRAND_NAME} - N8N Installer ===${reset}"
}

# Function to prompt the user to fill in information
function preencha_as_info() {
    echo -e "${branco}Por favor, preencha as informações a seguir:${reset}"
}

# Function to confirm the information
function conferindo_as_info() {
    echo -e "${branco}Conferindo as informações...${reset}"
}

# Function to display installing message
function instalando_msg() {
    echo -e "${branco}Instalando...${reset}"
}

# Function to display installed message
function instalado_msg() {
    echo -e "${verde}Instalação concluída com sucesso!${reset}"
}

# Function to prompt the user to save data
function guarde_os_dados_msg() {
    echo -e "${branco}Por favor, guarde os dados a seguir para acesso futuro:${reset}"
}

# Function to display credits
function creditos_msg() {
    echo -e "${branco}Obrigado por utilizar o ${BRAND_NAME}!${reset}"
}

# Function to ask if the user wants to install another application
function requisitar_outra_instalacao() {
    read -p "Deseja instalar outra aplicação? (Y/N): " confirmacao
    if [[ "$confirmacao" =~ ^[Yy]$ ]]; then
        menu_principal
    else
        echo "Finalizando o instalador."
        exit 0
    fi
}

# Function to wait for a stack to be online
function wait_stack() {
    stack_name="$1"
    echo "Aguardando a stack $stack_name ficar online..."
    max_wait_time=600
    wait_interval=10
    elapsed_time=0
    while [ $elapsed_time -lt $max_wait_time ]; do
        replicas=$(docker stack services $stack_name --format '{{.Name}} {{.Replicas}}' | awk '{print $2}' | grep -E '^1/1$' | wc -l)
        total_services=$(docker stack services $stack_name --format '{{.Name}}' | wc -l)
        if [ "$replicas" -eq "$total_services" ]; then
            echo "A stack $stack_name está online."
            break
        else
            echo "Aguardando os serviços da stack $stack_name ficarem online..."
            sleep $wait_interval
            elapsed_time=$((elapsed_time + wait_interval))
        fi
    done
    if [ $elapsed_time -ge $max_wait_time ]; then
        echo "Timeout ao aguardar a stack $stack_name ficar online."
    fi
}

# Function to wait for 30 seconds
function wait_30_sec() {
    echo "Aguardando 30 segundos..."
    sleep 30
}

# Function to check if Postgres container exists
function verificar_container_postgres() {
    if docker service ls | grep -q 'postgres_postgres'; then
        echo "Postgres já está instalado."
        return 0
    else
        echo "Postgres não está instalado."
        return 1
    fi
}

# Function to get Postgres password
function pegar_senha_postgres() {
    # Assume that the postgres password is stored in /root/dados_vps/dados_postgres
    if [ -f /root/dados_vps/dados_postgres ]; then
        senha_postgres=$(grep 'Senha do Postgres' /root/dados_vps/dados_postgres | awk '{print $4}')
    else
        echo "Arquivo de dados do Postgres não encontrado."
        senha_postgres=$(openssl rand -hex 12)
        echo "Senha do Postgres: $senha_postgres"
    fi
}

# Function to create a database in Postgres
function criar_banco_postgres_da_stack() {
    database_name="$1"
    # Create database in Postgres
    echo "Criando banco de dados $database_name no Postgres..."
    docker exec -i postgres_postgres psql -U postgres -c "CREATE DATABASE $database_name;"
}

# Function to install Postgres
function ferramenta_postgres() {
    # Install Postgres using Docker
    echo "Instalando Postgres..."
    senha_postgres=$(openssl rand -hex 12)
    # Create stack for Postgres
    cat > postgres.yaml <<EOL
version: "3.7"
services:
  postgres:
    image: postgres:latest
    environment:
      - POSTGRES_PASSWORD=$senha_postgres
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - $nome_rede_interna
    deploy:
      placement:
        constraints:
          - node.role == manager
volumes:
  postgres_data:
    external: true
    name: postgres_data
networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
    docker stack deploy -c postgres.yaml postgres
    # Save Postgres password
    mkdir -p dados_vps
    echo "Senha do Postgres: $senha_postgres" > dados_vps/dados_postgres
}

# Function to wait for Postgres to be ready
function wait_for_postgres() {
    echo "Aguardando o Postgres estar pronto..."
    sleep 10
}

# Function to check if Redis container exists
function verificar_container_redis() {
    if docker service ls | grep -q 'redis_redis'; then
        echo "Redis já está instalado."
        return 0
    else
        echo "Redis não está instalado."
        return 1
    fi
}

# Function to install Redis
function ferramenta_redis() {
    # Install Redis using Docker
    echo "Instalando Redis..."
    # Create stack for Redis
    cat > redis.yaml <<EOL
version: "3.7"
services:
  redis:
    image: redis:latest
    networks:
      - $nome_rede_interna
    deploy:
      placement:
        constraints:
          - node.role == manager
networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL
    docker stack deploy -c redis.yaml redis
}

# Function to allow editing the stack before deployment
function stack_editavel() {
    echo "Deseja editar a stack antes de implantá-la? (Y/N)"
    read -r edit_stack
    if [[ "$edit_stack" =~ ^[Yy]$ ]]; then
        nano "${STACK_NAME}.yaml"
    fi
    docker stack deploy --prune --resolve-image always -c "${STACK_NAME}.yaml" "${STACK_NAME}"
    if [ $? -eq 0 ]; then
        echo "Deploy da stack ${STACK_NAME} realizado com sucesso."
    else
        echo "Erro ao realizar o deploy da stack ${STACK_NAME}."
    fi
}

# Function to install Traefik and Portainer
function instalar_traefik_e_portainer() {
    clear
    nome_traefik_e_portainer
    preencha_as_info

    while true; do
        # Prompt for Portainer domain
        echo -e "${branco}Passo${amarelo} 1/4${reset}"
        echo -en "${amarelo}Digite o Dominio para o Portainer (ex: portainer.seudominio.com): ${reset}" && read -r url_portainer
        echo ""

        # Prompt for server name
        echo -e "${branco}Passo${amarelo} 2/4${reset}"
        echo -e "${amarelo}--> Não pode conter Espaços e/ou caracteres especiais"
        echo -en "${amarelo}Escolha um nome para o seu servidor (ex: MeuServidor): ${reset}" && read -r nome_servidor
        echo ""

        # Prompt for internal network name
        echo -e "${branco}Passo${amarelo} 3/4${reset}"
        echo -e "${amarelo}--> Não pode conter Espaços e/ou caracteres especiais."
        echo -en "${amarelo}Digite um nome para sua rede interna (ex: MinhaRede): ${reset}" && read -r nome_rede_interna
        echo ""

        # Prompt for SSL email
        echo -e "${branco}Passo${amarelo} 4/4${reset}"
        echo -en "${amarelo}Digite um endereço de Email válido (ex: email@seudominio.com): ${reset}" && read -r email_ssl
        echo ""

        clear
        nome_traefik_e_portainer
        conferindo_as_info

        echo -e "${amarelo}Link do Portainer:${branco} $url_portainer${reset}"
        echo ""
        echo -e "${amarelo}Nome do Servidor:${branco} $nome_servidor${reset}"
        echo ""
        echo -e "${amarelo}Rede interna:${branco} $nome_rede_interna${reset}"
        echo ""
        echo -e "${amarelo}Email:${branco} $email_ssl${reset}"
        echo ""
        echo ""

        read -p "As respostas estão corretas? (Y/N): " confirmacao
        if [[ "$confirmacao" =~ ^[Yy]$ ]]; then
            clear
            instalando_msg
            break
        else
            clear
            nome_traefik_e_portainer
            preencha_as_info
        fi
    done

    # Installation steps
    echo -e "${branco}• INICIANDO A INSTALAÇÃO DO TRAEFIK ${amarelo}[1/8]${reset}"
    echo ""
    sleep 1

    # Save VPS data
    mkdir -p dados_vps
    cat > dados_vps/dados_vps <<EOL
nome_servidor="$nome_servidor"
nome_rede_interna="$nome_rede_interna"
email_ssl="$email_ssl"
url_portainer="$url_portainer"
EOL

    # Update and configure VPS
    echo -e "${branco}• ATUALIZANDO E CONFIGURANDO A VPS ${amarelo}[2/8]${reset}"
    echo ""
    sleep 1

    sudo apt-get update -y
    sudo apt-get upgrade -y
    sudo timedatectl set-timezone "$DEFAULT_TIMEZONE"
    sudo apt-get install -y apt-utils
    hostnamectl set-hostname "$nome_servidor"
    sudo sed -i "s/127.0.0.1[[:space:]]localhost/127.0.0.1 $nome_servidor/g" /etc/hosts
    sudo apt-get install -y apparmor-utils
    echo ""

    # Install Docker Swarm
    echo -e "${branco}• INSTALANDO DOCKER SWARM ${amarelo}[3/8]${reset}"
    echo ""
    sleep 1

    read -r ip _ <<<$(hostname -I)
    curl -fsSL https://get.docker.com | bash
    systemctl enable docker
    systemctl start docker
    sleep 5

    max_attempts=3
    attempt=0

    while [ $attempt -le $max_attempts ]; do
        docker swarm init --advertise-addr "$ip"
        if [ $? -eq 0 ]; then
            echo "Docker Swarm iniciado com sucesso."
            break
        else
            echo "Falha ao iniciar Docker Swarm. Tentativa $attempt de $max_attempts."
            attempt=$((attempt + 1))
            sleep 5
        fi
    done

    if [ $attempt -gt $max_attempts ]; then
        echo "Não foi possível iniciar o Docker Swarm após $max_attempts tentativas."
        exit 1
    fi
    echo ""

    # Create internal network
    echo -e "${branco}• CRIANDO REDE INTERNA ${amarelo}[4/8]${reset}"
    echo ""
    sleep 1

    docker network create --driver=overlay "$nome_rede_interna"
    echo ""

    # Install Traefik
    echo -e "${branco}• INSTALANDO TRAEFIK ${amarelo}[5/8]${reset}"
    echo ""
    sleep 1

    cat > traefik.yaml <<EOL
version: "3.7"
services:
  traefik:
    image: traefik:v2.11.2
    command:
      - "--api.dashboard=true"
      - "--providers.docker.swarmMode=true"
      - "--providers.docker.endpoint=unix:///var/run/docker.sock"
      - "--providers.docker.exposedbydefault=false"
      - "--providers.docker.network=$nome_rede_interna"
      - "--entrypoints.web.address=:80"
      - "--entrypoints.web.http.redirections.entryPoint.to=websecure"
      - "--entrypoints.web.http.redirections.entryPoint.scheme=https"
      - "--entrypoints.web.http.redirections.entrypoint.permanent=true"
      - "--entrypoints.websecure.address=:443"
      - "--entrypoints.web.transport.respondingTimeouts.idleTimeout=3600"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge=true"
      - "--certificatesresolvers.letsencryptresolver.acme.httpchallenge.entrypoint=web"
      - "--certificatesresolvers.letsencryptresolver.acme.storage=/etc/traefik/letsencrypt/acme.json"
      - "--certificatesresolvers.letsencryptresolver.acme.email=$email_ssl"
      - "--log.level=DEBUG"
      - "--log.format=common"
      - "--log.filePath=/var/log/traefik/traefik.log"
      - "--accesslog=true"
      - "--accesslog.filepath=/var/log/traefik/access-log"
    deploy:
      placement:
        constraints:
          - node.role == manager
      labels:
        - "traefik.enable=true"
        - "traefik.http.middlewares.redirect-https.redirectscheme.scheme=https"
        - "traefik.http.middlewares.redirect-https.redirectscheme.permanent=true"
        - "traefik.http.routers.http-catchall.rule=Host(\`{host:.+}\`)"
        - "traefik.http.routers.http-catchall.entrypoints=web"
        - "traefik.http.routers.http-catchall.middlewares=redirect-https@docker"
        - "traefik.http.routers.http-catchall.priority=1"
    volumes:
      - "vol_certificates:/etc/traefik/letsencrypt"
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
    ports:
      - target: 80
        published: 80
        mode: host
      - target: 443
        published: 443
        mode: host
    networks:
      - $nome_rede_interna

volumes:
  vol_certificates:
    external: true
    name: volume_swarm_certificates

networks:
  $nome_rede_interna:
    external: true
    attachable: true
    name: $nome_rede_interna
EOL

    docker stack deploy --prune --resolve-image always -c traefik.yaml traefik

    echo ""
    echo -e "${branco}• ESPERANDO O TRAEFIK ESTAR ONLINE ${amarelo}[6/8]${reset}"
    echo ""
    sleep 1

    wait_stack "traefik"
    wait_30_sec

    # Install Portainer
    echo -e "${branco}• INSTALANDO PORTAINER ${amarelo}[7/8]${reset}"
    echo ""
    sleep 1

    cat > portainer.yaml <<EOL
version: "3.7"
services:
  agent:
    image: portainer/agent:latest
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - /var/lib/docker/volumes:/var/lib/docker/volumes
    networks:
      - $nome_rede_interna
    deploy:
      mode: global
      placement:
        constraints: [node.platform.os == linux]
  portainer:
    image: portainer/portainer-ce:latest
    command: -H tcp://tasks.agent:9001 --tlsskipverify
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
      - portainer_data:/data
    networks:
      - $nome_rede_interna
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints: [node.role == manager]
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.portainer.rule=Host(\`$url_portainer\`)"
        - "traefik.http.services.portainer.loadbalancer.server.port=9000"
        - "traefik.http.routers.portainer.tls.certresolver=letsencryptresolver"
        - "traefik.http.routers.portainer.service=portainer"
        - "traefik.docker.network=$nome_rede_interna"
        - "traefik.http.routers.portainer.entrypoints=websecure"
        - "traefik.http.routers.portainer.priority=1"

networks:
  $nome_rede_interna:
    external: true
    attachable: true
    name: $nome_rede_interna

volumes:
  portainer_data:
    external: true
    name: portainer_data
EOL

    docker stack deploy --prune --resolve-image always -c portainer.yaml portainer

    echo ""
    echo -e "${branco}• ESPERANDO O PORTAINER ESTAR ONLINE ${amarelo}[8/8]${reset}"
    echo ""
    sleep 1

    wait_stack "portainer"
    wait_30_sec

    # Save Portainer data
    mkdir -p dados_vps
    cat > dados_vps/dados_portainer <<EOL
[ PORTAINER ]

Dominio do portainer: https://$url_portainer

Usuario: Precisa criar dentro do portainer

Senha: Precisa criar dentro do portainer
EOL

    instalado_msg
    guarde_os_dados_msg

    echo -e "${verde}[ PORTAINER ]${reset}"
    echo ""
    echo -e "${branco}Dominio do portainer:${amarelo} https://$url_portainer${reset}"
    echo ""
    echo -e "${branco}Usuario:${amarelo} Precisa criar dentro do portainer${reset}"
    echo ""
    echo -e "${branco}Senha:${amarelo} Precisa criar dentro do portainer${reset}"
    echo ""
    echo -e "${branco}Observação:${amarelo} Você tem menos de 5 minutos para criar uma conta no Portainer. Caso exceda esse tempo, você precisará reiniciar o Portainer.${reset}"
    echo ""

    creditos_msg
    requisitar_outra_instalacao
}

# Function to install Chatwoot
function instalar_chatwoot() {
    clear
    nome_chatwoot
    preencha_as_info

    while true; do
        # Prompt for Chatwoot domain
        echo -e "${branco}Passo${amarelo} 1/6${reset}"
        echo -en "${amarelo}Digite o Dominio para o Chatwoot (ex: chatwoot.seudominio.com): ${reset}" && read -r url_chatwoot
        echo ""

        # Company name
        nome_empresa_chatwoot="$nome_servidor"

        # Prompt for SMTP email
        echo -e "${branco}Passo${amarelo} 2/6${reset}"
        echo -en "${amarelo}Digite o Email para SMTP (ex: email@seudominio.com): ${reset}" && read -r email_admin_chatwoot
        echo ""

        # Extract SMTP domain
        dominio_smtp_chatwoot=$(echo "$email_admin_chatwoot" | cut -d "@" -f 2)

        # Prompt for SMTP user
        echo -e "${branco}Passo${amarelo} 3/6${reset}"
        echo -e "${amarelo}--> Caso não tiver um usuário do email, use o próprio email abaixo"
        echo -en "${amarelo}Digite o Usuário para SMTP (ex: usuario ou email@seudominio.com): ${reset}" && read -r user_smtp_chatwoot
        echo ""

        # Prompt for SMTP password
        echo -e "${branco}Passo${amarelo} 4/6${reset}"
        echo -e "${amarelo}--> Sem caracteres especiais: \!#$ | Se estiver usando Gmail, use a senha de app"
        echo -en "${amarelo}Digite a Senha SMTP do Email (ex: Senha123): ${reset}" && read -r senha_email_chatwoot
        echo ""

        # Prompt for SMTP host
        echo -e "${branco}Passo${amarelo} 5/6${reset}"
        echo -en "${amarelo}Digite o Host SMTP do Email (ex: smtp.seudominio.com): ${reset}" && read -r smtp_email_chatwoot
        echo ""

        # Prompt for SMTP port
        echo -e "${branco}Passo${amarelo} 6/6${reset}"
        echo -en "${amarelo}Digite a porta SMTP do Email (ex: 465): ${reset}" && read -r porta_smtp_chatwoot

        # Determine SSL usage based on port
        if [ "$porta_smtp_chatwoot" -eq 465 ]; then
            sobre_ssl=true
        else
            sobre_ssl=false
        fi

        clear
        nome_chatwoot
        conferindo_as_info

        echo -e "${amarelo}Dominio do Chatwoot:${branco} $url_chatwoot${reset}"
        echo ""
        echo -e "${amarelo}Nome da Empresa:${branco} $nome_empresa_chatwoot${reset}"
        echo ""
        echo -e "${amarelo}Email do SMTP:${branco} $email_admin_chatwoot${reset}"
        echo ""
        echo -e "${amarelo}User do SMTP:${branco} $user_smtp_chatwoot${reset}"
        echo ""
        echo -e "${amarelo}Senha do SMTP:${branco} $senha_email_chatwoot${reset}"
        echo ""
        echo -e "${amarelo}Host SMTP:${branco} $smtp_email_chatwoot${reset}"
        echo ""
        echo -e "${amarelo}Porta SMTP:${branco} $porta_smtp_chatwoot${reset}"
        echo ""
        echo ""

        read -p "As respostas estão corretas? (Y/N): " confirmacao
        if [[ "$confirmacao" =~ ^[Yy]$ ]]; then
            clear
            instalando_msg
            break
        else
            clear
            nome_chatwoot
            preencha_as_info
        fi
    done

    # Installation steps
    echo -e "${branco}• INICIANDO A INSTALAÇÃO DO CHATWOOT ${amarelo}[1/6]${reset}"
    echo ""
    sleep 1

    # Check/install Postgres and Redis
    echo -e "${branco}• VERIFICANDO/INSTALANDO POSTGRES E REDIS ${amarelo}[2/6]${reset}"
    echo ""
    sleep 1

    verificar_container_postgres
    if [ $? -eq 0 ]; then
        pegar_senha_postgres
        criar_banco_postgres_da_stack "chatwoot"
    else
        ferramenta_postgres
        pegar_senha_postgres
        criar_banco_postgres_da_stack "chatwoot"
    fi

    verificar_container_redis
    if [ $? -ne 0 ]; then
        ferramenta_redis
    fi

    # Install Chatwoot
    echo -e "${branco}• INSTALANDO CHATWOOT ${amarelo}[3/6]${reset}"
    echo ""
    sleep 1

    encryption_key=$(openssl rand -hex 16)

    cat > chatwoot.yaml <<EOL
version: "3.7"
services:
  chatwoot_app:
    image: chatwoot/chatwoot:latest
    command: bundle exec rails s -p 3000 -b 0.0.0.0
    entrypoint: docker/entrypoints/rails.sh
    volumes:
      - chatwoot_storage:/app/storage
      - chatwoot_public:/app/public
      - chatwoot_mailer:/app/app/views/devise/mailer
      - chatwoot_mailers:/app/app/views/mailers
    networks:
      - $nome_rede_interna
    environment:
      - CHATWOOT_HUB_URL=https://example.com/setup#
      - INSTALLATION_NAME=$nome_empresa_chatwoot
      - SECRET_KEY_BASE=$encryption_key
      - FRONTEND_URL=https://$url_chatwoot
      - FORCE_SSL=true
      - DEFAULT_LOCALE=pt_BR
      - TZ=$DEFAULT_TIMEZONE
      - REDIS_URL=redis://redis:6379
      - POSTGRES_HOST=postgres
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$senha_postgres
      - POSTGRES_DATABASE=chatwoot
      - ACTIVE_STORAGE_SERVICE=local
      - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot>
      - SMTP_DOMAIN=$dominio_smtp_chatwoot
      - SMTP_ADDRESS=$smtp_email_chatwoot
      - SMTP_PORT=$porta_smtp_chatwoot
      - SMTP_SSL=$sobre_ssl
      - SMTP_USERNAME=$user_smtp_chatwoot
      - SMTP_PASSWORD=$senha_email_chatwoot
      - SMTP_AUTHENTICATION=login
      - SMTP_ENABLE_STARTTLS_AUTO=true
      - SMTP_OPENSSL_VERIFY_MODE=peer
      - MAILER_INBOUND_EMAIL_DOMAIN=$email_admin_chatwoot
      - NODE_ENV=production
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
      - RAILS_LOG_TO_STDOUT=true
      - USE_INBOX_AVATAR_FOR_BOT=true
      - ENABLE_ACCOUNT_SIGNUP=false
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.chatwoot_app.rule=Host(\`$url_chatwoot\`)
        - traefik.http.routers.chatwoot_app.entrypoints=websecure
        - traefik.http.routers.chatwoot_app.tls.certresolver=letsencryptresolver
        - traefik.http.routers.chatwoot_app.priority=1
        - traefik.http.routers.chatwoot_app.service=chatwoot_app
        - traefik.http.services.chatwoot_app.loadbalancer.server.port=3000
        - traefik.http.services.chatwoot_app.loadbalancer.passhostheader=true
        - traefik.http.middlewares.sslheader.headers.customrequestheaders.X-Forwarded-Proto=https
        - traefik.http.routers.chatwoot_app.middlewares=sslheader@docker

  chatwoot_sidekiq:
    image: chatwoot/chatwoot:latest
    command: bundle exec sidekiq -C config/sidekiq.yml
    volumes:
      - chatwoot_storage:/app/storage
      - chatwoot_public:/app/public
      - chatwoot_mailer:/app/app/views/devise/mailer
      - chatwoot_mailers:/app/app/views/mailers
    networks:
      - $nome_rede_interna
    environment:
      - CHATWOOT_HUB_URL=https://example.com/setup#
      - INSTALLATION_NAME=$nome_empresa_chatwoot
      - SECRET_KEY_BASE=$encryption_key
      - FRONTEND_URL=https://$url_chatwoot
      - FORCE_SSL=true
      - DEFAULT_LOCALE=pt_BR
      - TZ=$DEFAULT_TIMEZONE
      - REDIS_URL=redis://redis:6379
      - POSTGRES_HOST=postgres
      - POSTGRES_USERNAME=postgres
      - POSTGRES_PASSWORD=$senha_postgres
      - POSTGRES_DATABASE=chatwoot
      - ACTIVE_STORAGE_SERVICE=local
      - MAILER_SENDER_EMAIL=$email_admin_chatwoot <$email_admin_chatwoot>
      - SMTP_DOMAIN=$dominio_smtp_chatwoot
      - SMTP_ADDRESS=$smtp_email_chatwoot
      - SMTP_PORT=$porta_smtp_chatwoot
      - SMTP_SSL=$sobre_ssl
      - SMTP_USERNAME=$user_smtp_chatwoot
      - SMTP_PASSWORD=$senha_email_chatwoot
      - SMTP_AUTHENTICATION=login
      - SMTP_ENABLE_STARTTLS_AUTO=true
      - SMTP_OPENSSL_VERIFY_MODE=peer
      - MAILER_INBOUND_EMAIL_DOMAIN=$email_admin_chatwoot
      - NODE_ENV=production
      - RAILS_ENV=production
      - INSTALLATION_ENV=docker
      - RAILS_LOG_TO_STDOUT=true
      - USE_INBOX_AVATAR_FOR_BOT=true
      - ENABLE_ACCOUNT_SIGNUP=false
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

volumes:
  chatwoot_storage:
    external: true
    name: chatwoot_storage
  chatwoot_public:
    external: true
    name: chatwoot_public
  chatwoot_mailer:
    external: true
    name: chatwoot_mailer
  chatwoot_mailers:
    external: true
    name: chatwoot_mailers

networks:
  $nome_rede_interna:
    external: true
    name: $nome_rede_interna
EOL

    STACK_NAME="chatwoot"
    stack_editavel

    echo -e "${branco}• ESPERANDO SERVIÇO DO CHATWOOT ESTAR PRONTO ${amarelo}[4/6]${reset}"
    echo ""
    sleep 1

    wait_stack "chatwoot"

    # Migrate database
    echo -e "${branco}• MIGRANDO BANCO DE DADOS ${amarelo}[5/6]${reset}"
    echo ""
    sleep 1

    container_name="chatwoot_chatwoot_app"

    max_wait_time=1200
    wait_interval=60
    elapsed_time=0

    while [ $elapsed_time -lt $max_wait_time ]; do
      CONTAINER_ID=$(docker ps -q --filter "name=$container_name")
      if [ -n "$CONTAINER_ID" ]; then
        break
      fi
      sleep $wait_interval
      elapsed_time=$((elapsed_time + wait_interval))
    done

    if [ -z "$CONTAINER_ID" ]; then
      echo "O contêiner não foi encontrado após $max_wait_time segundos."
      exit 1
    fi

    docker exec -it "$CONTAINER_ID" bundle exec rails db:chatwoot_prepare

    # Enable super admin features
    echo -e "${branco}• ATIVANDO FUNÇÕES DO SUPER ADMIN ${amarelo}[6/6]${reset}"
    echo ""
    sleep 1

    wait_for_postgres

    docker exec -i "$CONTAINER_ID" psql -U postgres <<EOF
\c chatwoot;
update installation_configs set locked = false;
\q
EOF

    # Save Chatwoot data
    mkdir -p dados_vps
    cat > dados_vps/dados_chatwoot <<EOL
[ CHATWOOT ]

Dominio do Chatwoot: https://$url_chatwoot

Usuario: Precisa criar dentro do Chatwoot

Senha: Precisa criar dentro do Chatwoot
EOL

    wait_30_sec

    instalado_msg
    guarde_os_dados_msg

    echo -e "${verde}[ Chatwoot ]${reset}"
    echo ""
    echo -e "${branco}Dominio:${amarelo} https://$url_chatwoot${reset}"
    echo ""
    echo -e "${branco}Usuario:${amarelo} Precisa criar dentro do Chatwoot${reset}"
    echo ""
    echo -e "${branco}Senha:${amarelo} Precisa criar dentro do Chatwoot${reset}"
    echo ""

    creditos_msg
    requisitar_outra_instalacao
}

# Function to install N8N
function instalar_n8n() {
    clear
    nome_n8n
    preencha_as_info

    while true; do
        # Prompt for N8N editor domain
        echo -e "${branco}Passo${amarelo} 1/7${reset}"
        echo -en "${amarelo}Digite o dominio para o N8N (ex: n8n.seudominio.com): ${reset}" && read -r url_editorn8n
        echo ""

        # Prompt for N8N webhook domain
        echo -e "${branco}Passo${amarelo} 2/7${reset}"
        echo -en "${amarelo}Digite o dominio para o Webhook do N8N (ex: webhook.seudominio.com): ${reset}" && read -r url_webhookn8n
        echo ""

        # Prompt for SMTP email
        echo -e "${branco}Passo${amarelo} 3/7${reset}"
        echo -en "${amarelo}Digite o Email para SMTP (ex: email@seudominio.com): ${reset}" && read -r email_smtp_n8n
        echo ""

        # Prompt for SMTP user
        echo -e "${branco}Passo${amarelo} 4/7${reset}"
        echo -e "${amarelo}--> Caso não tiver um usuário do email, use o próprio email abaixo"
        echo -en "${amarelo}Digite o Usuário para SMTP (ex: usuario ou email@seudominio.com): ${reset}" && read -r usuario_smtp_n8n
        echo ""

        # Prompt for SMTP password
        echo -e "${branco}Passo${amarelo} 5/7${reset}"
        echo -e "${amarelo}--> Sem caracteres especiais: \!#$ | Se estiver usando Gmail, use a senha de app"
        echo -en "${amarelo}Digite a Senha SMTP do Email (ex: Senha123): ${reset}" && read -r senha_smtp_n8n
        echo ""

        # Prompt for SMTP host
        echo -e "${branco}Passo${amarelo} 6/7${reset}"
        echo -en "${amarelo}Digite o Host SMTP do Email (ex: smtp.seudominio.com): ${reset}" && read -r host_smtp_n8n
        echo ""

        # Prompt for SMTP port
        echo -e "${branco}Passo${amarelo} 7/7${reset}"
        echo -en "${amarelo}Digite a porta SMTP do Email (ex: 465): ${reset}" && read -r porta_smtp_n8n
        echo ""

        # Determine SSL usage based on port
        if [ "$porta_smtp_n8n" -eq 465 ]; then
            smtp_secure_smtp_n8n=true
        else
            smtp_secure_smtp_n8n=false
        fi

        clear
        nome_n8n
        conferindo_as_info

        echo -e "${amarelo}Dominio do N8N:${branco} $url_editorn8n${reset}"
        echo ""
        echo -e "${amarelo}Dominio para o Webhook:${branco} $url_webhookn8n${reset}"
        echo ""
        echo -e "${amarelo}Email do SMTP:${branco} $email_smtp_n8n${reset}"
        echo ""
        echo -e "${amarelo}Usuário do SMTP:${branco} $usuario_smtp_n8n${reset}"
        echo ""
        echo -e "${amarelo}Senha do Email:${branco} $senha_smtp_n8n${reset}"
        echo ""
        echo -e "${amarelo}Host SMTP do Email:${branco} $host_smtp_n8n${reset}"
        echo ""
        echo -e "${amarelo}Porta SMTP do Email:${branco} $porta_smtp_n8n${reset}"
        echo ""
        echo -e "${amarelo}Secure SMTP do Email:${branco} $smtp_secure_smtp_n8n${reset}"
        echo ""

        read -p "As respostas estão corretas? (Y/N): " confirmacao
        if [[ "$confirmacao" =~ ^[Yy]$ ]]; then
            clear
            instalando_msg
            break
        else
            clear
            nome_n8n
            preencha_as_info
        fi
    done

    # Installation steps
    echo -e "${branco}• INICIANDO A INSTALAÇÃO DO N8N ${amarelo}[1/4]${reset}"
    echo ""
    sleep 1

    # Check/install Postgres and Redis
    echo -e "${branco}• VERIFICANDO/INSTALANDO POSTGRES E REDIS ${amarelo}[2/4]${reset}"
    echo ""
    sleep 1

    verificar_container_postgres
    if [ $? -eq 0 ]; then
        pegar_senha_postgres
    else
        ferramenta_postgres
        pegar_senha_postgres
    fi

    criar_banco_postgres_da_stack "n8n_queue"

    verificar_container_redis
    if [ $? -ne 0 ]; then
        ferramenta_redis
    fi

    # Install N8N
    echo -e "${branco}• INSTALANDO N8N ${amarelo}[3/4]${reset}"
    echo ""
    sleep 1

    encryption_key=$(openssl rand -hex 16)

    cat > n8n.yaml <<EOL
version: "3.7"
services:
  n8n_editor:
    image: n8nio/n8n:latest
    command: start
    networks:
      - $nome_rede_interna
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres
      - N8N_ENCRYPTION_KEY=$encryption_key
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/note/.n8n/nodes
      - N8N_SMTP_SENDER=$email_smtp_n8n
      - N8N_SMTP_USER=$usuario_smtp_n8n
      - N8N_SMTP_PASS=$senha_smtp_n8n
      - N8N_SMTP_HOST=$host_smtp_n8n
      - N8N_SMTP_PORT=$porta_smtp_n8n
      - N8N_SMTP_SSL=$smtp_secure_smtp_n8n
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash,moment-with-locales
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - GENERIC_TIMEZONE=$DEFAULT_TIMEZONE
      - TZ=$DEFAULT_TIMEZONE
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.n8n_editor.rule=Host(\`$url_editorn8n\`)
        - traefik.http.routers.n8n_editor.entrypoints=websecure
        - traefik.http.routers.n8n_editor.priority=1
        - traefik.http.routers.n8n_editor.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n_editor.service=n8n_editor
        - traefik.http.services.n8n_editor.loadbalancer.server.port=5678
        - traefik.http.services.n8n_editor.loadbalancer.passHostHeader=1

  n8n_webhook:
    image: n8nio/n8n:latest
    command: webhook
    networks:
      - $nome_rede_interna
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres
      - N8N_ENCRYPTION_KEY=$encryption_key
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/note/.n8n/nodes
      - N8N_SMTP_SENDER=$email_smtp_n8n
      - N8N_SMTP_USER=$usuario_smtp_n8n
      - N8N_SMTP_PASS=$senha_smtp_n8n
      - N8N_SMTP_HOST=$host_smtp_n8n
      - N8N_SMTP_PORT=$porta_smtp_n8n
      - N8N_SMTP_SSL=$smtp_secure_smtp_n8n
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash,moment-with-locales
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - GENERIC_TIMEZONE=$DEFAULT_TIMEZONE
      - TZ=$DEFAULT_TIMEZONE
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M
      labels:
        - traefik.enable=true
        - traefik.http.routers.n8n_webhook.rule=(Host(\`$url_webhookn8n\`))
        - traefik.http.routers.n8n_webhook.entrypoints=websecure
        - traefik.http.routers.n8n_webhook.priority=1
        - traefik.http.routers.n8n_webhook.tls.certresolver=letsencryptresolver
        - traefik.http.routers.n8n_webhook.service=n8n_webhook
        - traefik.http.services.n8n_webhook.loadbalancer.server.port=5678
        - traefik.http.services.n8n_webhook.loadbalancer.passHostHeader=1

  n8n_worker:
    image: n8nio/n8n:latest
    command: worker --concurrency=10
    networks:
      - $nome_rede_interna
    environment:
      - DB_TYPE=postgresdb
      - DB_POSTGRESDB_DATABASE=n8n_queue
      - DB_POSTGRESDB_HOST=postgres
      - DB_POSTGRESDB_PORT=5432
      - DB_POSTGRESDB_USER=postgres
      - DB_POSTGRESDB_PASSWORD=$senha_postgres
      - N8N_ENCRYPTION_KEY=$encryption_key
      - N8N_HOST=$url_editorn8n
      - N8N_EDITOR_BASE_URL=https://$url_editorn8n/
      - WEBHOOK_URL=https://$url_webhookn8n/
      - N8N_PROTOCOL=https
      - NODE_ENV=production
      - EXECUTIONS_MODE=queue
      - N8N_REINSTALL_MISSING_PACKAGES=true
      - N8N_COMMUNITY_PACKAGES_ENABLED=true
      - N8N_NODE_PATH=/home/note/.n8n/nodes
      - N8N_SMTP_SENDER=$email_smtp_n8n
      - N8N_SMTP_USER=$usuario_smtp_n8n
      - N8N_SMTP_PASS=$senha_smtp_n8n
      - N8N_SMTP_HOST=$host_smtp_n8n
      - N8N_SMTP_PORT=$porta_smtp_n8n
      - N8N_SMTP_SSL=$smtp_secure_smtp_n8n
      - QUEUE_BULL_REDIS_HOST=redis
      - QUEUE_BULL_REDIS_PORT=6379
      - QUEUE_BULL_REDIS_DB=2
      - NODE_FUNCTION_ALLOW_EXTERNAL=moment,lodash,moment-with-locales
      - EXECUTIONS_DATA_PRUNE=true
      - EXECUTIONS_DATA_MAX_AGE=336
      - GENERIC_TIMEZONE=$DEFAULT_TIMEZONE
      - TZ=$DEFAULT_TIMEZONE
    deploy:
      mode: replicated
      replicas: 1
      placement:
        constraints:
          - node.role == manager
      resources:
        limits:
          cpus: "1"
          memory: 1024M

networks:
  $nome_rede_interna:
    name: $nome_rede_interna
    external: true
EOL

    STACK_NAME="n8n"
    stack_editavel

    echo -e "${branco}• VERIFICANDO SERVIÇO ${amarelo}[4/4]${reset}"
    echo ""
    sleep 1

    wait_stack "n8n"
    wait_30_sec

    # Save N8N data
    mkdir -p dados_vps
    cat > dados_vps/dados_n8n <<EOL
[ N8N ]

Dominio do N8N: https://$url_editorn8n

Dominio do Webhook: https://$url_webhookn8n

Email: Precisa criar no primeiro acesso do N8N

Senha: Precisa criar no primeiro acesso do N8N
EOL

    instalado_msg
    guarde_os_dados_msg

    echo -e "${verde}[ N8N ]${reset}"
    echo ""
    echo -e "${amarelo}Dominio:${branco} https://$url_editorn8n${reset}"
    echo ""
    echo -e "${amarelo}Email:${branco} Precisa criar no primeiro acesso do N8N${reset}"
    echo ""
    echo -e "${amarelo}Senha:${branco} Precisa criar no primeiro acesso do N8N${reset}"
    echo ""

    creditos_msg
    requisitar_outra_instalacao
}

# Main menu function
function menu_principal() {
    clear
    echo -e "${verde}=== ${BRAND_NAME} - Instalador Automático ===${reset}"
    echo "Escolha a aplicação que deseja instalar:"
    echo "1) Traefik e Portainer"
    echo "2) Chatwoot"
    echo "3) N8N"
    echo "4) Sair"
    read -p "Opção: " opcao

    case $opcao in
        1)
            instalar_traefik_e_portainer
            ;;
        2)
            instalar_chatwoot
            ;;
        3)
            instalar_n8n
            ;;
        4)
            echo "Saindo..."
            exit 0
            ;;
        *)
            echo "Opção inválida!"
            menu_principal
            ;;
    esac
}

# Start the script
menu_principal
